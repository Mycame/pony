# 零知识证明身份验证系统

基于默克尔树的隐私保护身份验证系统，使用零知识证明技术在不暴露用户公钥的情况下证明用户身份。

## 系统概述

本系统实现了一个完整的零知识证明身份验证机制，主要特点：

1. **隐私保护**: 用户在验证身份时无需暴露公钥
2. **数学安全**: 基于密码学哈希函数和默克尔树结构
3. **高效验证**: 验证复杂度为 O(log n)，其中 n 为用户数量
4. **防重放攻击**: 包含时间戳验证机制

## 核心技术原理

### 1. 默克尔树构建

```
系统初始化阶段：
1. 收集所有用户的公钥 {PK₁, PK₂, ..., PKₙ}
2. 计算每个公钥的哈希值作为叶子节点：Lᵢ = H(PKᵢ)
3. 构建二叉默克尔树，根节点 R 代表整个用户集合
4. 公开根哈希 R，保密各用户公钥
```

### 2. 零知识证明协议

本系统采用基于承诺-挑战-响应的零知识证明协议：

#### 证明生成阶段：
1. **承诺 (Commitment)**: 
   - 用户生成随机数 r
   - 计算承诺 C = H(PK || r)

2. **挑战 (Challenge)**:
   - 使用 Fiat-Shamir 启发式生成挑战
   - e = H(C || R || L)，其中 L 为叶子哈希

3. **响应 (Response)**:
   - 计算响应 z = r + e·s (简化版本)
   - 生成默克尔路径证明

#### 验证阶段：
1. **路径验证**: 验证从叶子到根的默克尔路径
2. **挑战重现**: 重新计算挑战值并验证一致性
3. **响应验证**: 验证响应与承诺、挑战的数学关系
4. **时间戳验证**: 防止重放攻击

### 3. 安全性分析

- **完整性 (Completeness)**: 诚实的证明者总能通过验证
- **可靠性 (Soundness)**: 恶意证明者无法伪造有效证明
- **零知识性 (Zero-Knowledge)**: 验证过程不泄露公钥信息

## 文件结构

```
├── index.html          # 主页面
├── styles.css          # 样式文件
├── crypto-utils.js     # 加密工具模块
├── merkle-tree.js      # 默克尔树实现
├── zk-proof.js         # 零知识证明系统
├── app.js              # 主应用逻辑
└── README.md           # 说明文档
```

## 使用方法

### 1. 启动系统

```bash
# 使用 Python 启动本地服务器
python3 -m http.server 8000

# 或使用 Node.js
npx http-server -p 8000
```

### 2. 操作流程

1. **系统初始化**:
   - 设置用户数量 (2-32)
   - 点击"初始化系统"生成用户集合和默克尔树

2. **生成证明**:
   - 选择要验证的用户身份
   - 点击"生成零知识证明"

3. **验证证明**:
   - 点击"验证证明"查看验证结果

## 技术实现细节

### 默克尔树类 (MerkleTree)

```javascript
class MerkleTree {
    async buildTree(publicKeys)           // 构建树
    async generateMembershipProof(pk)     // 生成成员证明
    async verifyMembershipProof(proof)    // 验证成员证明
    getTreeVisualization()                // 获取树的可视化
}
```

### 零知识证明系统 (ZKProofSystem)

```javascript
class ZKProofSystem {
    async initializeSystem(userCount)     // 初始化系统
    async generateZKProof(userIndex)      // 生成零知识证明
    async verifyZKProof(proof)           // 验证零知识证明
}
```

### 加密工具 (CryptoUtils)

```javascript
class CryptoUtils {
    static async sha256(data)             // SHA-256 哈希
    static generatePublicKey()            // 生成公钥
    static async combineHashes(l, r)      // 组合哈希
}
```

## 数学基础

### 默克尔树验证

给定叶子节点 L 和根节点 R，验证路径 {s₁, s₂, ..., sₖ}：

```
H₀ = L
H₁ = H(H₀ || s₁) 或 H(s₁ || H₀)
H₂ = H(H₁ || s₂) 或 H(s₂ || H₁)
...
Hₖ = R
```

### 零知识证明验证

验证三元组 (C, e, z) 满足：
- e = H(C || R || L)
- 响应 z 与承诺 C、挑战 e 保持一致性

## 安全考虑

1. **哈希函数安全性**: 使用 SHA-256，具有抗碰撞性
2. **随机数生成**: 使用密码学安全的随机数生成器
3. **时间戳验证**: 防止重放攻击
4. **输入验证**: 严格验证所有输入参数

## 性能特性

- **空间复杂度**: O(n) 存储 n 个用户
- **证明大小**: O(log n) 路径长度
- **验证时间**: O(log n) 哈希计算
- **初始化时间**: O(n log n) 树构建

## 扩展可能

1. **批量验证**: 同时验证多个用户身份
2. **动态更新**: 支持用户集合的动态增删
3. **隐私增强**: 集成更高级的零知识证明协议
4. **分布式验证**: 支持多方验证场景

## 注意事项

- 本实现为教学演示版本，生产环境需要更严格的安全措施
- 私钥管理在实际应用中需要硬件安全模块支持
- 建议结合数字签名等技术增强安全性

## 许可证

MIT License - 仅供学习和研究使用